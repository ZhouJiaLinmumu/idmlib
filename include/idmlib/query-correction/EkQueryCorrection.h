/*
 * EnglishQueryCorrection.h
 *
 *  Created on: Nov 3, 2010
 *      Author: wps
 */

#ifndef EKQUERYCORRECTION_H_
#define EKQUERYCORRECTION_H_

#include "UAutomata.h"
#include "DAutomata.h"
#include "CandidateScoreItem.h"
#include "ErrorModel.h"
#include <boost/noncopyable.hpp>
#include <sdb/SequentialDB.h>

namespace sf1r
{

typedef izenelib::sdb::unordered_sdb_fixed<unsigned int, float,
izenelib::util::ReadWriteLock> CogramType;

class EkQueryCorrection : public boost::noncopyable
{
public:
    EkQueryCorrection(const string& path, const std::string& workingPath, int ed);
    ~EkQueryCorrection();

    /**
     * @brief The main interface to refine a user query,the query can be set of tokens
     * @param queryUString         the inputed query of the user.
     * @param refinedQueryUString  the corrected query, if no correction is done, this string is returned empty.
     * @param collectionName
     * @return true if success false if failed.*/
    bool getRefinedQuery(const std::string& collectionName,
                         const UString& queryUString, UString& refinedQueryUString);

    void
    updateCogramAndDict(
        const std::list<
        std::pair<izenelib::util::UString, uint32_t> >& recentQueryList);


    void
    updateCogramAndDict(
        const std::string& collectionName,
        const std::list<
        std::pair<izenelib::util::UString, uint32_t> >& recentQueryList);

    bool inDict(const izenelib::util::UString& ustr)
    {
        return inDict_(ustr);
    }

    /**
    * @brief Initialize some member variables
    * @return true if success false if failed.
    */
    bool initialize();

    void warmUp()
    {
        cogram_->fillCache();
    }

protected:


    void initDictHash(
        izenelib::am::rde_hash<izenelib::util::UString, bool>& hashdb,
        const std::string& fileName);

    void constructDAutoMata(const std::string& path);

    /**
     * @brief Get the candidates of a query token using universal automata algorithm
     * @param queryToken       the inputed token.
     * @param s                the dicitonary based automata
     * @param queryCandidates  the correction candidates generated
     * @return true if success false if failed.
     */
    void candidateGeneration(const UString& queryToken, DictState *s,
                             std::vector<UString>& queryCandidates, bool queryFlag);

    /**
     * @brief Rank the candidates according to the error model and language model.
     * @param queryToken              the inputed tokens.
     * @param queryCandidates         the correction candidates generated by candidateGeneration()
     * @param scoreCandidates         the scored candidates
     * @return true if success false if failed.
     */
    bool candidateRanking(const UString& queryToken,
                          const std::vector<UString>& queryCandidates, std::vector<
                          CandidateScoreItem>& scoredCandidates, bool queryFlag);

    /**
     * @brief Get the best correction path.
     * @param queryTokens     the tokens of the original query.
     * @param queryCandidates the ranked candidate list of each token.
     * @param refinedTokens   the selected best path.
     * @return true if success false if failed.
     */
    bool getBestPath(const std::vector<UString>& queryTokens, const vector<
                     vector<CandidateScoreItem> >& queryCandidates, std::vector<
                     std::string>& refinedTokens);

    /**
     * @brief get the probability of a candidate given a string token. This is the erro model used.
     * @param queryToken     the query token
     * @param queryCandidate the candidate to be evaluated.
     * @return the evaluation of candidate
     */
    float
    getErrorScore(const UString& queryToken, const UString& queryCandidate);

    /**
     * @brief Compute the transition probability of two adjacent words.
     * @param w1     the first word
     * @param w2     the second word
     * @return the transition probability of two words
     */
    float transProb(const std::string& w1, const std::string& w2);
    /**
     * @brief Tokenize the query to tokens,first use the simple tokenizer supported by UString, in the future should use LAManager to update. It should be same when tokenize Wiki to train the
     *  bigram and unigram.
     * @param queryUString         the inputed query of the user.
     * @param queryTokens          the tokens of input query
     * @return true if success false if failed.
     */
    bool
    Tokenize(const UString& queryUString, std::vector<UString>& queryTokens);
    /**
     * @brief Convert string into int using hash function
     * @param str    the string needs to be hashed
     * @return the hash number of str
     */
    unsigned int hashFunc(const std::string &str);

    float transProb(const izenelib::util::UString& w1,
                    const izenelib::util::UString& w2);

    unsigned int hashFunc(const izenelib::util::UString& ustr);

    /**
     * @brief Generate the bit vector as input when given one query and referenced letters
     * @param queryUString     the inputed query of the user.
     * @param bitVector        the generate bit vector
     * @param characters       the referenced letters eg:'a'-'z' in english
     */
    void generateBitVector(const UString& queryUString,
                           vector<mychar>& characters, vector<string> &bitVector);

private:
    bool getCandidateItems_(const std::string& collectionName,
                            const std::vector<UString>& tokens, std::vector<std::vector<
                            CandidateScoreItem> >& candidateItems);

    bool getBestPath_(const std::string& collectionName, const std::vector<
                      izenelib::util::UString>& tokens, const std::vector<std::vector<
                      CandidateScoreItem> >& queryCandidates, std::vector<
                      UString>& refinedCandidate);

    bool inDict_(const izenelib::util::UString& str);

private:
    std::string path_;

    std::string workingPath_;

    bool activate_;

    /**
     *  max edit distance used to canididae generation
     */
    int max_ed_;
    /**
     *  sdb_fixedhash used to store pair of word and corresponding frequency computed from wikipedia
     */
    boost::shared_ptr<CogramType> cogram_;
    /**
     *  state vector used to store states generated by universal automata
     */
    vector<STATE> states_;
    /**
     *  hash_map used to store universal automata transitions
     */
    rde::hash_map<rde_tran, int> autoMaton_;
    /**
     *  Dictionary automata generated according to english dictionary
     */
    DictState *s_;
    /**
     *  Dictionary automata generated according to korean dictionary
     */
    DictState *s_k_;

    /**
     *  directory of english dictionary
     */
    std::string dictEN_;
    /**
     *  directory of korean dictionary
     */
    std::string dictKR_;

    /**
     *  lexion used to combine the dictionary
     */
    rde_hash lexicon_;
    /**
     *  vector used to store korean jomas
     */

    vector<mychar> jomas_;
    /**
     *  hash_map used to store pair of korean jomas and hash number
     */
    rde_map jomaMap_;
    /**
     *  vector used to store english letters
     */
    vector<mychar> letters_;
    /**
     *  hash_map used to store pair of english letter and hash number
     */
    rde_map alphabet_;
    /**
     *  directory of english matrix file used for error model
     */
    //const char* matrix_;
    std::string matrix_;

    ErrorModel model_;

    izenelib::am::rde_hash<izenelib::util::UString, bool> dictENHash_;

    izenelib::am::rde_hash<izenelib::util::UString, bool> dictKRHash_;

    boost::mutex logMutex_;

};

//item used for candidate generation,including both dictionary automata and universal automata
struct CandidateGenerateItem
{
    int pos;//the position of one character in word
    UString labels;//string which is made of labels in transition
    DictState *q_d;//dictionary automata
    int q_u;//universal automata
    CandidateGenerateItem()
    {
    }
    CandidateGenerateItem(int i, UString uStr, DictState *dState, int uStateNo) :
            pos(i), labels(uStr), q_d(dState), q_u(uStateNo)
    {
    }

};

}
#endif

