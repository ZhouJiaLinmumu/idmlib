/**
 * @file idmlib/semantic_space/semantic_interpreter.h
 * @author Zhongxia Li
 * @date Mar 10, 2011
 * @brief Vector space base
 */
#ifndef SEMANTIC_SPACE_H_
#define SEMANTIC_SPACE_H_

#include <set>
#include <iostream>

#include <idmlib/idm_types.h>
#include <idmlib/semantic_space/term_doc_matrix_defs.h>
#include <idmlib/util/FSUtil.hpp>

NS_IDMLIB_SSP_BEGIN

class SemanticSpace
{
public:
	enum eSSPInitType {
		CREATE, // Create new semantic space data
		LOAD    // Load from existed data
	};

public:
	SemanticSpace(
			const std::string& sspPath,
			SemanticSpace::eSSPInitType initType = SemanticSpace::CREATE)
	: sspPath_(sspPath)
	{
		idmlib::util::FSUtil::normalizeFilePath(sspPath_);
	}
	virtual ~SemanticSpace() {}

public:
	/**
	 * @defgroup Common interfaces for building semantic space
	 * @{
	 */

	/**
	 * @brief Incrementally process documents one by one.
	 * @param docid document id
	 * @param termids id of terms in the document, such as terms generated by LA.
	 */
	virtual void ProcessDocument(docid_t& docid, std::vector<termid_t>& termids) = 0;

	/**
	 * @brief Post process after all documents are processed.
	 */
	virtual void ProcessSpace() = 0;

	/** @} */

	virtual count_t getDocNum() { return 0; } ;

	virtual bool getTermIndex(termid_t& termid, index_t& termidx) { return false; }

	virtual weight_t getTermDocWeight(termid_t& termid, index_t& docIdx) { return 0; }

	virtual bool getTermIds(std::set<termid_t>& termIds) {};

	virtual bool getTermVector(termid_t termId, std::vector<docid_t> termVec) {};

	virtual void Print() {}

protected:
	std::string sspPath_;
};

NS_IDMLIB_SSP_END

#endif /* SEMANTIC_SPACE_H_ */
