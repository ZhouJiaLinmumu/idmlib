/**
 * @file idmlib/semantic_space/semantic_interpreter.h
 * @author Zhongxia Li
 * @date Mar 10, 2011
 * @brief Vector space base
 */
#ifndef SEMANTIC_SPACE_H_
#define SEMANTIC_SPACE_H_

#include <set>
#include <iostream>

#include <idmlib/idm_types.h>
#include <idmlib/semantic_space/term_doc_matrix_defs.h>
#include <idmlib/util/FSUtil.hpp>
#include <ir/index_manager/index/LAInput.h>

using namespace izenelib::ir::indexmanager;
using namespace idmlib::ssp;

NS_IDMLIB_SSP_BEGIN

typedef std::map<termid_t, weight_t> term_df_map;
typedef izenelib::util::FileObject<term_df_map> term_df_file;
typedef izenelib::util::FileObject<std::vector<docid_t> > doc_list_file;

class TermInfoReader
{
public:
    TermInfoReader(const string& infoPath)
    : infoPath_(infoPath)
    {
        boost::shared_ptr<term_df_file> term2dfFile(new term_df_file(infoPath + "/term_df_map"));
        boost::shared_ptr<doc_list_file> doclistFile(new doc_list_file(infoPath + "/doc_list"));
        term2dfFile->Load();
        doclistFile->Load();
        termid2df_ = term2dfFile->GetValue();
        docList_ = doclistFile->GetValue();
        cout << "TermInfoReader: [doc " << docList_.size() << ", term " << termid2df_.size() << "]" << endl;
    }

public:
    count_t getDocNum() {
        return docList_.size();
    }

    weight_t getDFByTermId(uint32_t termid) {
        return termid2df_[termid];
    }

private:
    string infoPath_;
    term_df_map termid2df_;
    std::vector<docid_t> docList_;
};

class SemanticSpace
{
public:
	enum eSSPInitType {
		CREATE, // Create new semantic space data
		LOAD    // Load from existed data
	};

public:
	SemanticSpace(
			const std::string& sspPath,
			SemanticSpace::eSSPInitType initType = SemanticSpace::CREATE,
			const std::string resPath = string("./utest/esa_chwiki_all") )
	: sspPath_(sspPath)
	, isPreLoadTermInfo_(true)
	{
		idmlib::util::FSUtil::normalizeFilePath(sspPath_);

		if (initType ==  SemanticSpace::CREATE) {
		    DLOG(INFO) << "Create Semantic Space Data." << endl;
			// clear existed files
			idmlib::util::FSUtil::del(sspPath_);
		}

		term2dfFile_.reset(new term_df_file(sspPath_ + "/term_df_map"));
		doclistFile_.reset(new doc_list_file(sspPath_ + "/doc_list"));
		if (initType == SemanticSpace::LOAD) {
			term2dfFile_->Load();
			termid2df_ = term2dfFile_->GetValue();
			doclistFile_->Load();
			docList_ = doclistFile_->GetValue();
			DLOG(INFO) << "Load Semantic Space Data: [doc " << docList_.size() << ", term " << termid2df_.size() << "]" << endl;
		}
		cout << sspPath_ << endl;

        if (isPreLoadTermInfo_) {
		    pTermInfoReader_.reset(new TermInfoReader(resPath));
        }

	}

	virtual ~SemanticSpace() {}

public:
	/**
	 * @defgroup Common interfaces for building semantic space
	 * @{
	 */

	/**
	 * @brief Incrementally process documents one by one.
	 * @param docid document id
	 * @param termids id of terms in the document, such as terms generated by LA.
	 */
	virtual void ProcessDocument(docid_t& docid, TermIdList& termIdList,
	        IdmTermList& termList = NULLTermList) = 0;

	/**
	 * @brief Post process after all documents are processed.
	 */
	virtual void ProcessSpace() = 0;

	virtual void SaveSpace()
	{
		term2dfFile_->SetValue(termid2df_);
		term2dfFile_->Save();
		doclistFile_->SetValue(docList_);
		doclistFile_->Save();
	}

	/** @} */


	virtual count_t getDocNum() { return 0; }

	std::vector<docid_t>& getDocList()
	{
		return docList_;
	}

	/// Available if it's forward(doc) index
	virtual void getVectorByDocid(docid_t& docid, term_sp_vector& termsVec) {}

	/// Available if it's inverted(term) index
	virtual void getVectorByTermid(termid_t& termid, doc_sp_vector& docsVec) {}

	virtual void Print() {}

public:
//	typedef std::map<termid_t, weight_t> term_df_map;
//	typedef izenelib::util::FileObject<term_df_map> term_df_file;
//	typedef izenelib::util::FileObject<std::vector<docid_t> > doc_list_file;

protected:
	std::string sspPath_;

	// statistics of whole collection, permanent
	term_df_map termid2df_;
	std::vector<docid_t> docList_;

	boost::shared_ptr<term_df_file> term2dfFile_;
	boost::shared_ptr<doc_list_file> doclistFile_;

	bool isPreLoadTermInfo_;
	boost::shared_ptr<TermInfoReader> pTermInfoReader_;
};

NS_IDMLIB_SSP_END

#endif /* SEMANTIC_SPACE_H_ */
